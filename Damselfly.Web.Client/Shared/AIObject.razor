@inject IPeopleService peopleService
@inject IUserStatusService statusService
@inject ContextMenuService contextMenuService
@inject NavigationManager NavigationManager
@inject ILogger<AIObject> logger

<div class="object" title="@ObjectName" style="@ObjectStylePos" id="@theObject.PersonId">
    @if (Editing)
    {
        <div class="object-editor">
            <MudAutocomplete T="string" Label="Name" Placeholder="Add Name" SearchFunc="SearchNames"
                             @bind-Value="@TypeAheadName" ShowProgressIndicator="true" MinCharacters="2"
                             CoerceValue="true" DebounceInterval="250" Clearable="true" Immediate="false"
                             Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Sell"
                             ariant="UIConstants.MudVariant" AutoFocus="true" @onblur="@LostFocus"/> 
        </div>
    }
    else
    {
        <div class="object-text" @onclick="EditName" title="Click to Edit">@ObjectName</div>
    }
</div>

@code {

    [Parameter]
    public ImageObject theObject { get; set; }

    [Parameter]
    public Action<ImageObject> OnObjectChanged { get; set; }

    private bool Editing { get; set; }

    private string nameText;
    private string TypeAheadName { get { return nameText; } set { _ = UpdateName(value); } }
    private string tagSearchText { get; set; }

    public string ObjectName => theObject.ToString();
    public string ObjectTitle => $"{ObjectName} - click to edit";

    private string ObjectStylePos
    {
        get
        {
            var imgWidth = theObject.Image.MetaData.Width > 0 ? theObject.Image.MetaData.Width : 800;
            var imgHeight = theObject.Image.MetaData.Height > 0 ? theObject.Image.MetaData.Height : 800;

            var xPercent = theObject.RectX * 100 / imgWidth;
            var yPercent = theObject.RectY * 100 / imgHeight;
            var wPercent = theObject.RectWidth * 100 / imgWidth;
            var hPercent = theObject.RectHeight * 100 / imgHeight;
            var pos = $"top:{yPercent}%;left:{xPercent}%;width:{wPercent}%;height:{hPercent}%;";

            return pos;
        }
    }

    private void ShowContextMenu(MouseEventArgs args)
    {
        if (theObject.Type != ImageObject.ObjectTypes.Face.ToString())
            return;

        var menuList = new List<ContextMenuItem>
    {
                new() { Text = $"Find more photos containing this person", Value = 0 },
            };

        contextMenuService.Open(args, menuList, async args =>
        {
            contextMenuService.Close();
            switch (args.Value)
            {
                case 0:
                    NavigationManager.NavigateTo($"/?personid={theObject.PersonId}");
                    break;
            }
        });
    }

    private void LostFocus()
    {
        Editing = false;
        StateHasChanged();
    }

    private void EditName()
    {
        if (!Editing && theObject.Type == ImageObject.ObjectTypes.Face.ToString())
        {
            Editing = true;
            StateHasChanged();
        }
    }

    private async Task<IEnumerable<string>> SearchNames(string text)
    {
        var searchText = text.Trim();
        IEnumerable<string> results = new List<string>();

        // Store the search text which is used in the NotFound template
        tagSearchText = searchText;

        // Only query the DB if we have more than 2 chars.
        if (searchText.Length > 1)
        {
            var names = await peopleService.GetPeopleNames(searchText);

            if (!names.Contains(searchText, StringComparer.OrdinalIgnoreCase))
                names.Insert(0, searchText);

            results = names;
        }

        return results;
    }

    private async Task UpdateName(string name)
    {
        if (!string.IsNullOrEmpty(name))
        {
            logger.LogInformation($"Saving name: {name}");
            TypeAheadName = string.Empty;

            StateHasChanged();

            await peopleService.UpdateName(theObject, name);

            statusService.UpdateStatus($"Name saved as '{name}'");

            // Reset the tag
            Editing = false;

            OnObjectChanged?.Invoke(theObject);
        }
    }

}