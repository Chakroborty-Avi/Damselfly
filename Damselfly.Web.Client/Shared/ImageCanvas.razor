@using Damselfly.Core.DbModels.Models.TransformationModels;

@inject HttpClient restClient
@inject ITagService tagService
@inject ILogger<ImageCanvas> logger

@implements IDisposable

<div class="image-canvas">
    <div class="tool-pallette">
        <MudSlider @bind-Value="lightenFactor" Min="-255" Max="255" Step=1 @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />
        <MudSlider @bind-Value="contrast" Min="-0.25f" Max="0.25f" Step="0.01f" @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />

        <MudSelect @bind-Value="mode" @bind-Value:after="Repaint">
            <MudSelectItem Value="SKBlendMode.Clear">None</MudSelectItem>
            <MudSelectItem Value="SKBlendMode.Color">Col</MudSelectItem>
            <MudSelectItem Value="SKBlendMode.Hue">Hue</MudSelectItem>
            <MudSelectItem Value="SKBlendMode.Saturation">Sat</MudSelectItem>
        </MudSelect>
        <MudSlider @bind-Value="hue" Min="0" Max="360" Step="1" @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />
        <MudSlider @bind-Value="saturation" Min="0" Max="100" Step="1" @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />
        <MudSlider @bind-Value="luminosity" Min="0" Max="100" Step="1" @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />

        <MudIconButton Icon="@Icons.Material.Filled.Crop" Color="@CropColour" OnClick="DoCrop" />
        <MudIconButton Icon="@Icons.Material.Filled.RotateLeft" OnClick="() => DoRotate(-90)" />
        <MudIconButton Icon="@Icons.Material.Filled.RotateRight" OnClick="() => DoRotate(90)" />
        <MudIconButton Icon="@Icons.Material.Filled.MonochromePhotos" OnClick="DoMono" />
    </div>
    @if (sourceBitmap == null)
    {
        <div class="loading">
            <MudProgressCircular Indeterminate="true" />
        </div>
    }
    else
    {
        <SKGLView @ref="glViewRef" OnPaintSurface="OnPaintSurface" EnableRenderLoop="@isDragging" IgnorePixelScaling="false"
                  class="@Class" @onmousedown="MouseDown" @onmouseup="MouseUp" @onmousemove="MouseMove" @onmousewheel="MouseWheel" />
    }
</div>

@code {
    [Parameter]
    public Image Image { get; set; }

    [Parameter]
    public string Class { get; set; }

    public Color CropColour => isCropping ? Color.Tertiary : Color.Primary;

    private SKGLView glViewRef;
    private SKBitmap? sourceBitmap;
    private int currentImageId = 0;
    private CancellationTokenSource loadCancellationSource = new();
    private int lightenFactor = 0;
    private float contrast = 0.0f;
    private int rotation = 0;

    private SKBlendMode mode = SKBlendMode.Color;
    private float hue = 0;
    private float saturation = 0;
    private float luminosity = 0;

    private SKPoint? dragStart;
    private SKPoint? dragEnd;
    private bool isDragging;
    private bool isCropping;

    private SKRect paintArea = new SKRect(0, 0, 0, 0);
    private float paintScale = 0f;
    private float lastDPI = 1.0f;
    private float zoomAmount = 0.0f;
    private SKPoint zoomOffset = new SKPoint();

    private List<ITransform> transformations = new();

    private void Repaint()
    {
        if (glViewRef != null)
            glViewRef.Invalidate();
    }

    /// <summary>
    /// SKEncodedOrigin.RightTop: 90
    /// SKEncodedOrigin.BottomRight: 180
    /// SKEncodedOrigin.RightTop: 90
    /// SKEncodedOrigin.LeftBottom: 270
    /// </summary>
    /// <param name="degrees"></param>
    private void DoRotate(int degrees)
    {
        var oldBitmap = sourceBitmap;

        rotation += degrees;
        if (rotation >= 360)
            rotation = 0;
        if (rotation < 0)
            rotation = 270;

        tagService.SetExifFieldAsync(new[] { Image.ImageId }, ExifOperation.ExifType.Rotate, rotation.ToString() );

        sourceBitmap = Rotate(oldBitmap, degrees);
        oldBitmap.Dispose();
        ClearCrop();
        Repaint();
    }

    private SKRect? GetDragRect()
    {
        if (dragStart.HasValue && dragEnd.HasValue)
        {
            SKRect rect = new SKRect(dragStart.Value.X * lastDPI,
                                     dragStart.Value.Y * lastDPI,
                                     dragEnd.Value.X * lastDPI,
                                     dragEnd.Value.Y * lastDPI);

            if (rect.Left > rect.Right)
            {
                var temp = rect.Left;
                rect.Left = rect.Right;
                rect.Right = temp;
            }

            if (rect.Top > rect.Bottom)
            {
                var temp = rect.Top;
                rect.Top = rect.Bottom;
                rect.Bottom = temp;
            }

            return rect;
        }

        return null;
    }

    private void DoMono()
    {
        transformations.Add(new MonoTransform());
        Repaint();
    }

    private void DoCrop()
    {
        if (isCropping)
        {
            isCropping = false;

            var rect = GetDragRect();

            if (rect.HasValue)
            {
                var crop = new CropTransform
                {
                    Left = (int)((rect.Value.Left - paintArea.Left) * paintScale),
                    Top = (int)((rect.Value.Top - paintArea.Top) * paintScale),
                    Width = (int)(rect.Value.Width * paintScale),
                    Height = (int)(rect.Value.Height * paintScale)
                };

                transformations.Add(crop);
                ClearDrag();
                Repaint();
            }
        }
        else
        {
            ClearCrop();
            isCropping = true;
            Repaint();
        }

        StateHasChanged();
    }

    private void ClearCrop()
    {
        // Remove the previous crop
        transformations = transformations.Where(x => !(x is CropTransform)).ToList();
    }

    private void GetSurfaceDPI()
    {
        var obj = typeof(SKGLView).GetField("dpi", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

        double dpi = 1;
        if (obj != null)
            dpi = (double)obj.GetValue(glViewRef)!;

        lastDPI = (float)dpi;
    }

    private SKPoint GetCoords(MouseEventArgs e)
    {
        var x = (float)e.OffsetX;
        var y = (float)e.OffsetY;
        return new SKPoint(x, y);
    }

    private void MouseWheel(WheelEventArgs e)
    {
        zoomAmount += (float)(e.DeltaY / 2.0f);
        Repaint();
    }

    private void MouseMove(MouseEventArgs e)
    {
        if (isDragging)
        {
            if (isCropping)
                dragEnd = GetCoords(e);
            else if (zoomAmount != 0)
                zoomOffset = GetCoords(e);
            Repaint();
        }

    }

    private void MouseDown(MouseEventArgs e)
    {
        if (e.Button == 0)
        {
            if (isCropping)
                dragStart = GetCoords(e);

            isDragging = true;
        }
    }

    private void MouseUp(MouseEventArgs e)
    {
        if (dragStart.HasValue)
        {
            var mouseUp = GetCoords(e);

            if (dragStart == mouseUp)
                ClearDrag();
        }

        isDragging = false;
        Repaint();
    }

    private void ClearDrag()
    {
        dragStart = null;
        dragEnd = null;
    }

    private void SetBitmap(SKBitmap bitmap)
    {
        Dispose();
        sourceBitmap = bitmap;
        Repaint();
    }


    private SKBitmap LoadOriented( Stream stream )
    {
        var codec = SKCodec.Create(stream);
        return SKBitmap.Decode(codec);
    }

    private async Task LoadImage(CancellationToken token)
    {
        var url = Image.ThumbUrl(ThumbSize.Medium);

        SKBitmap? bmp = null;
        try
        {
            using var imageStream = await restClient.GetStreamAsync(url, token);

            bmp = LoadOriented(imageStream);

            if (bmp != null && !token.IsCancellationRequested)
            {
                logger.LogInformation($"Loaded image {url} successfully");
                SetBitmap(bmp);
            }
            else
                logger.LogError($"Failed to decode {url} - bitmap was null");
        }
        catch (OperationCanceledException)
        {
            logger.LogWarning($"Cancelling low-res load as hi-res image is already loaded {url}");
        }
        catch (Exception ex)
        {
            logger.LogError($"Unable to load image {url}: {ex}");
        }
    }

    private async Task LoadHiResImage()
    {
        var url = Image.ThumbUrl(ThumbSize.ExtraLarge);

        SKBitmap? bmp = null;
        try
        {
            using var imageStream = await restClient.GetStreamAsync(url);

            bmp = SKBitmap.Decode(imageStream);

            if (bmp != null)
            {
                logger.LogInformation($"Loaded hi-res image {url} successfully");
                // Cancel the low-res load.
                loadCancellationSource.Cancel();
                SetBitmap(bmp);
            }
            else
                logger.LogError($"Failed to decode hi-res {url} - bitmap was null");
        }
        catch (Exception ex)
        {
            logger.LogError($"Unable to load hi-res image {url}: {ex}");
        }
    }

    protected override async Task OnParametersSetAsync()
    {

        if (Image != null)
        {
            if (Image.ImageId != currentImageId)
            {
                currentImageId = Image.ImageId;
                loadCancellationSource.TryReset();

                await LoadImage(loadCancellationSource.Token);
                await LoadHiResImage();
            }
        }
        else
        {
            currentImageId = 0;
            Dispose();
        }

        await base.OnParametersSetAsync();
    }

    public void Dispose()
    {
        if (sourceBitmap != null)
        {
            sourceBitmap.Dispose();
            sourceBitmap = null;
        }
    }

    private void OnPaintSurface(SKPaintGLSurfaceEventArgs e)
    {
        GetSurfaceDPI();

        // the the canvas and properties
        var canvas = e.Surface.Canvas;

        // make sure the canvas is blank
        canvas.Clear(SKColors.Black);

        var surfaceSize = e.BackendRenderTarget.Size;

        if (sourceBitmap != null)
        {
            SKBitmap paintBitmap = sourceBitmap;

            var croppedBmp = ApplyCrop(sourceBitmap);

            if (croppedBmp != null)
                paintBitmap = croppedBmp;

            // Calculate the area we're going to paint onto - centering and scaling to fit the canvas
            var rect = GetRenderRect(paintBitmap, surfaceSize);

            // Save the scale and the offset
            paintScale = (sourceBitmap.Width / rect.Width);
            paintArea = rect;

            using var scaledImage = new SKBitmap((int)rect.Width, (int)rect.Height);
            sourceBitmap.ScalePixels(scaledImage.PeekPixels(), SKFilterQuality.Medium);

            // Calculate the pan/zoom viewport
            var aspectRatio = (float)paintBitmap.Height / (float)paintBitmap.Width;
            var zoomViewPort = new SKRect(0, 0, paintBitmap.Width, paintBitmap.Height);
            if (zoomAmount > 0)
            {
                zoomViewPort.Inflate(zoomAmount * -1, zoomAmount * -1 * aspectRatio);
                zoomViewPort.Offset(zoomOffset);
            }

            using var filters = CalculateColourFilters(canvas);

            // Paint the actual bitmap
            canvas.DrawBitmap(paintBitmap, zoomViewPort, rect, filters);

            using (SKPaint paint = new SKPaint())
            {
                paint.Color = SKColor.FromHsl(hue, saturation, luminosity);
                paint.BlendMode = mode;
                canvas.DrawRect(rect, paint);
            }

            DrawDragRect(canvas);

            if (System.Diagnostics.Debugger.IsAttached)
            {
                using var paint = new SKPaint
                {
                    IsAntialias = true,
                    StrokeWidth = 10f,
                    StrokeCap = SKStrokeCap.Round,
                    TextAlign = SKTextAlign.Center,
                    TextSize = 24,
                    Color = new SKColor(200, 200, 200),
                };

                canvas.DrawText($"{Image.FileName} - {surfaceSize} R:{rotation} Z: {zoomAmount}", surfaceSize.Width / 2, surfaceSize.Height - 10f, paint);
            }

            if (croppedBmp != null)
                croppedBmp.Dispose();
        }
    }

    private SKBitmap? ApplyCrop(SKBitmap source)
    {
        SKBitmap? croppedBmp = null;

        // See if we have a crop transformation
        var crop = transformations.Where(x => x is CropTransform).Cast<CropTransform>().FirstOrDefault();

        if (crop != null)
        {
            var cropRect = new SKRectI(crop.Left,
                                       crop.Top,
                                       crop.Left + crop.Width,
                                       crop.Top + crop.Height);

            croppedBmp = new SKBitmap(crop.Width, crop.Height);

            source.ExtractSubset(croppedBmp, cropRect);
        }

        return croppedBmp;
    }

    private SKPaint CalculateColourFilters(SKCanvas canvas)
    {
        var filters = new SKPaint();
        return filters;

        if (transformations.Any(x => x is MonoTransform))
        {
            filters.ColorFilter = blackAndWhite;
        }
        else if (contrast != 0)
        {
            filters.ColorFilter = SKColorFilter.CreateHighContrast(false, SKHighContrastConfigInvertStyle.NoInvert, contrast);
        }
        else if (saturation != 1)
        {
            // 1.2 => 0
            // 1 => 0
            // 0.9 => 0.1
            // 0.5 => 0.5
            var invert = saturation < 1 ? 1 - saturation : 0;
            filters.ColorFilter = SKColorFilter.CreateColorMatrix(new float[]
                    {
                    saturation, invert, invert, 0, 0,
                    invert, saturation, invert, 0, 0,
                    invert, invert, saturation, 0, 0,
                    0, 0, 0, 1, 0 });
        }
        else if (lightenFactor != 0)
        {
            var color = lightenFactor > 0 ? SKColors.White : SKColors.Black;
            var factor = (byte)Math.Abs(lightenFactor);
            filters.ColorFilter = SKColorFilter.CreateLighting(color, new SKColor(factor, factor, factor));
        }

        return filters;
    }

    private void DrawDragRect(SKCanvas canvas)
    {
        var dragRect = GetDragRect();

        if (dragRect.HasValue)
        {
            using var dragBorder = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                StrokeCap = SKStrokeCap.Round,
                StrokeWidth = 2f,
                Color = SKColor.Parse("#ffffff"),
                PathEffect = SKPathEffect.CreateDash(new[] { 5 * lastDPI, 2 * lastDPI }, 20)
            };

            canvas.DrawRect(dragRect.Value, dragBorder);
        }
    }

    // https://learn.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/blend-modes/separable
    // From https://learn.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/color-filters

    private SKColorFilter blackAndWhite =
    SKColorFilter.CreateColorMatrix(new float[]
            {
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0,     0,     0,     1, 0
                });

    public static SKBitmap Rotate(SKBitmap bitmap, double angle)
    {
        double radians = Math.PI * angle / 180;
        float sine = (float)Math.Abs(Math.Sin(radians));
        float cosine = (float)Math.Abs(Math.Cos(radians));
        int originalWidth = bitmap.Width;
        int originalHeight = bitmap.Height;
        int rotatedWidth = (int)(cosine * originalWidth + sine * originalHeight);
        int rotatedHeight = (int)(cosine * originalHeight + sine * originalWidth);

        var rotatedBitmap = new SKBitmap(bitmap.Height, bitmap.Width);

        using (var surface = new SKCanvas(rotatedBitmap))
        {
            surface.Clear();
            surface.Translate(rotatedWidth / 2, rotatedHeight / 2);
            surface.RotateDegrees((float)angle);
            surface.Translate(-originalWidth / 2, -originalHeight / 2);
            surface.DrawBitmap(bitmap, new SKPoint());
        }
        return rotatedBitmap;
    }

    /// <summary>
    /// Given a Bitmap and a canvas surface, calculates the rectangle for it to be
    /// painted - at the right aspect ratio, and the right size, to fill the canvas
    /// as much as possible.
    /// </summary>
    /// <param name="bmp"></param>
    /// <param name="canvasSize"></param>
    /// <returns></returns>
    private static SKRect GetRenderRect(SKBitmap bmp, SKSize canvasSize)
    {
        float bmpAspectRatio = (float)bmp.Width / (float)bmp.Height;
        float renderHeight = canvasSize.Height;
        float renderWidth = renderHeight * bmpAspectRatio;
        float scaleFactor = 1.0f;

        if (renderHeight > canvasSize.Height)
            scaleFactor = canvasSize.Height / renderHeight;
        else if (renderWidth > canvasSize.Width)
            scaleFactor = canvasSize.Width / renderWidth;

        renderWidth *= scaleFactor;
        renderHeight *= scaleFactor;

        var origin = new SKPoint((canvasSize.Width - renderWidth) / 2.0f,
                                 (canvasSize.Height - renderHeight) / 2.0f);

        return new SKRect(origin.X, origin.Y, renderWidth + origin.X, renderHeight + origin.Y);
    }
}