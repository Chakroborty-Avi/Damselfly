@using Damselfly.Core.DbModels.Models.TransformationModels;

@inject HttpClient restClient
@inject ILogger<ImageCanvas> logger

@implements IDisposable

<div class="image-canvas">
    <SKGLView @ref="glViewRef" OnPaintSurface="OnPaintSurface" EnableRenderLoop="@isDragging" IgnorePixelScaling="false"
              class="@Class" @onmousedown="MouseDown" @onmouseup="MouseUp" @onmousemove="MouseMove" @onmousewheel="MouseWheel"/>
    <div class="tool-pallette">
        <MudSlider @bind-Value="lightenFactor" @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />
        <MudSlider @bind-Value="saturation" Max="1.5f" Step="0.01f" Min="0.5f" @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />
        <MudIconButton Icon="@Icons.Material.Filled.Crop" Disabled="@(!CanCrop)" OnClick="DoCrop" />
        <MudIconButton Icon="@Icons.Material.Filled.RotateLeft" OnClick="() => DoRotate(-90)" />
        <MudIconButton Icon="@Icons.Material.Filled.RotateRight" OnClick="() => DoRotate(90)" />
        <MudIconButton Icon="@Icons.Material.Filled.MonochromePhotos" OnClick="DoMono" />
    </div>
</div>

@code {
    [Parameter]
    public Image Image { get; set; }

    [Parameter]
    public string Class { get; set; }

    private SKGLView glViewRef;
    private SKBitmap? sourceBitmap;
    private bool isHiRes = false;
    private int currentImageId = 0;
    private CancellationTokenSource loadCancellationSource = new();
    private string mouseStatus;
    private byte lightenFactor = 0;
    private float saturation = 1.0f;
    private int rotation = 0;

    private SKPoint? dragStart;
    private SKPoint? dragEnd;
    private bool isDragging;
    private bool CanCrop => dragEnd.HasValue || transformations.Any(x => x is CropTransform);

    private SKRect paintArea = new SKRect( 0, 0, 0, 0 );
    private float paintScale = 0f;
    private float lastDPI = 1.0f;
    private float zoomAmount = 0.0f;


    private List<ITransform> transformations = new();

    private void Repaint()
    {
        if (glViewRef != null)
            glViewRef.Invalidate();
    }

    private void DoRotate(int degrees)
    {
        rotation += degrees;
        if (rotation == -90)
            rotation = 270;
        if (rotation == 360)
            rotation = 0;
        Repaint();
    }

    private SKRect? GetDragRect()
    {
        if (dragStart.HasValue && dragEnd.HasValue)
        {
            SKRect rect = new SKRect(dragStart.Value.X * lastDPI,
                                     dragStart.Value.Y * lastDPI,
                                     dragEnd.Value.X * lastDPI,
                                     dragEnd.Value.Y * lastDPI);

            if ( rect.Left > rect.Right )
            {
                var temp = rect.Left;
                rect.Left = rect.Right;
                rect.Right = temp;
            }

            if( rect.Top > rect.Bottom )
            {
                var temp = rect.Top;
                rect.Top = rect.Bottom;
                rect.Bottom = temp;
            }

            return rect;
        }

        return null;
    }

    private void DoMono()
    {
        transformations.Add(new MonoTransform());
        Repaint();
    }

    private void DoCrop()
    {
        if( transformations.Any( x => x is CropTransform ))
        {
            // Remove the previous crop
            transformations = transformations.Where(x => !(x is CropTransform)).ToList();
            Repaint();
        }
        else
        {
            var rect = GetDragRect();

            if( rect.HasValue )
            {
                var crop = new CropTransform
                {
                    Left = (int)((rect.Value.Left - paintArea.Left) * paintScale),
                    Top = (int)((rect.Value.Top - paintArea.Top ) * paintScale),
                    Width = (int)(rect.Value.Width * paintScale),
                    Height = (int)(rect.Value.Height * paintScale)
                };

                transformations.Add(crop);
                ClearDrag();
                Repaint();
            }
        }
    }

    private void GetSurfaceDPI()
    {
        var obj = typeof(SKGLView).GetField("dpi", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

        double dpi = 1;
        if (obj != null)
            dpi = (double)obj.GetValue(glViewRef)!;

        lastDPI = (float)dpi;
    }

    private SKPoint GetCoords(MouseEventArgs e)
    {
        var x = (float)e.OffsetX;
        var y = (float)e.OffsetY;
        return new SKPoint(x, y);
    }

    private void MouseWheel(WheelEventArgs e )
    {
        zoomAmount += (float)(e.DeltaY / 2.0f);
        Repaint();
    }

    private void MouseMove(MouseEventArgs e)
    {
        if (isDragging)
        {
            dragEnd = GetCoords(e);
            Repaint();
        }
    }

    private void MouseDown(MouseEventArgs e)
    {
        dragStart = GetCoords(e);
        isDragging = true;
    }

    private void MouseUp(MouseEventArgs e)
    {
        if (dragStart.HasValue)
        {
            var mouseUp = GetCoords(e);

            if (dragStart == mouseUp)
                ClearDrag();
        }

        isDragging = false;
        Repaint();
    }

    private void ClearDrag()
    {
        dragStart = null;
        dragEnd = null;
    }

    private void SetBitmap(SKBitmap bitmap)
    {
        Dispose();
        sourceBitmap = bitmap;
        Repaint();
    }

    private async Task LoadImage(CancellationToken token)
    {
        var url = Image.ThumbUrl(ThumbSize.Medium);

        SKBitmap? bmp = null;
        try
        {
            using var imageStream = await restClient.GetStreamAsync(url, token);

            bmp = SKBitmap.Decode(imageStream);

            if (bmp != null && !token.IsCancellationRequested)
            {
                logger.LogInformation($"Loaded image {url} successfully");
                SetBitmap(bmp);
                isHiRes = false;
            }
            else
                logger.LogError($"Failed to decode {url} - bitmap was null");
        }
        catch (OperationCanceledException)
        {
            logger.LogWarning($"Cancelling low-res load as hi-res image is already loaded {url}");
        }
        catch (Exception ex)
        {
            logger.LogError($"Unable to load image {url}: {ex}");
        }
    }

    private async Task LoadHiResImage()
    {
        var url = Image.ThumbUrl(ThumbSize.ExtraLarge);

        SKBitmap? bmp = null;
        try
        {
            using var imageStream = await restClient.GetStreamAsync(url);

            bmp = SKBitmap.Decode(imageStream);

            if (bmp != null)
            {
                logger.LogInformation($"Loaded hi-res image {url} successfully");
                // Cancel the low-res load.
                loadCancellationSource.Cancel();
                SetBitmap(bmp);
                isHiRes = true;
            }
            else
                logger.LogError($"Failed to decode hi-res {url} - bitmap was null");
        }
        catch (Exception ex)
        {
            logger.LogError($"Unable to load hi-res image {url}: {ex}");
        }
    }

    protected override async Task OnParametersSetAsync()
    {

        if (Image != null)
        {
            if (Image.ImageId != currentImageId)
            {
                currentImageId = Image.ImageId;
                loadCancellationSource.TryReset();

                await LoadImage(loadCancellationSource.Token);
                await LoadHiResImage();
            }
        }
        else
        {
            currentImageId = 0;
            Dispose();
        }

        await base.OnParametersSetAsync();
    }

    public void Dispose()
    {
        if (sourceBitmap != null)
        {
            sourceBitmap.Dispose();
            sourceBitmap = null;
        }
    }

    private void OnPaintSurface(SKPaintGLSurfaceEventArgs e)
    {
        GetSurfaceDPI();

        // the the canvas and properties
        var canvas = e.Surface.Canvas;

        // make sure the canvas is blank
        canvas.Clear(SKColors.Black);

        using var paint = new SKPaint
        {
            IsAntialias = true,
            StrokeWidth = 10f,
            StrokeCap = SKStrokeCap.Round,
            TextAlign = SKTextAlign.Center,
            TextSize = 24,
            Color = new SKColor(200, 200, 200),
        };

        var surfaceSize = e.BackendRenderTarget.Size;

        if (sourceBitmap != null)
        {
            SKBitmap paintBitmap = sourceBitmap;
            bool copied = false;

            // Now the transformations
            var crop = transformations.Where(x => x is CropTransform).Cast<CropTransform>().FirstOrDefault();

            if( crop != null )
            {
                using var cropBorder = new SKPaint
                {
                    Style = SKPaintStyle.Stroke,
                    StrokeCap = SKStrokeCap.Round,
                    StrokeWidth = 2f,
                    Color = SKColor.Parse("#aa6666"),
                };

                var cropRect = new SKRectI(crop.Left,
                                           crop.Top,
                                           crop.Left + crop.Width,
                                           crop.Top + crop.Height);

                paintBitmap = new SKBitmap( crop.Width, crop.Height);
                copied = true;

                sourceBitmap.ExtractSubset(paintBitmap, cropRect);
            }

            if( rotation != 0 )
            {
                var rotatedBmp = Rotate(paintBitmap, rotation);
                if( crop != null )
                {
                    // We will have copied the source for the crop, so dispose that
                    paintBitmap.Dispose();
                }
                paintBitmap = rotatedBmp;
            }

            // Calculate the area we're going to paint onto - centering and scaling to fit the canvas
            var rect = GetRenderRect(paintBitmap, surfaceSize);

            // Save the scale and the offset
            paintScale = (sourceBitmap.Width / rect.Width);
            paintArea = rect;

            using var scaledImage = new SKBitmap((int)rect.Width, (int)rect.Height);
            sourceBitmap.ScalePixels(scaledImage.PeekPixels(), SKFilterQuality.Medium);

            using var filters = new SKPaint();

            if( transformations.Any( x => x is MonoTransform ) )
            {
                filters.ColorFilter = blackAndWhite;
            }
            else if ( saturation != 1 )
            {
                var invert = saturation < 1 ? 1 - saturation : 0;
                filters.ColorFilter = SKColorFilter.CreateColorMatrix(new float[]
                            {
                    saturation, invert, invert, 0, 0,
                    invert, saturation, invert, 0, 0,
                    invert, invert, saturation, 0, 0,
                    0, 0, 0, 1, 0 });
            }
            else if ( lightenFactor > 0 )
            {
                filters.ColorFilter = SKColorFilter.CreateLighting(SKColors.White, new SKColor(lightenFactor, lightenFactor, lightenFactor));
            }

            var aspectRatio = (float)paintBitmap.Height / (float)paintBitmap.Width;
            var zoomRect = new SKRect(0, 0, paintBitmap.Width, paintBitmap.Height);
            if (zoomAmount > 0)
                zoomRect.Inflate(zoomAmount * -1, zoomAmount * -1 * aspectRatio);

            // Paint the actual bitmap
            canvas.DrawBitmap(paintBitmap, zoomRect, rect, filters);

            var dragRect = GetDragRect();

            if (dragRect.HasValue)
            {
                using var dragBorder = new SKPaint
                {
                    Style = SKPaintStyle.Stroke,
                    StrokeCap = SKStrokeCap.Round,
                    StrokeWidth = 2f,
                    Color = SKColor.Parse("#ffffff"),
                    PathEffect = SKPathEffect.CreateDash(new[] { 5 * lastDPI, 2 * lastDPI }, 20)
                };

                canvas.DrawRect(dragRect.Value, dragBorder);
            }

            canvas.DrawText($"{Image.FileName}\n{surfaceSize} R:{rotation}", surfaceSize.Width / 2, surfaceSize.Height - 10f, paint);

            if( copied )
                paintBitmap.Dispose();
        }
    }

    // https://learn.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/blend-modes/separable
    // From https://learn.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/color-filters

    private SKColorFilter blackAndWhite =
        SKColorFilter.CreateColorMatrix(new float[]
                {
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0,     0,     0,     1, 0
                });

    public static SKBitmap Rotate(SKBitmap bitmap, double angle)
    {
        double radians = Math.PI * angle / 180;
        float sine = (float)Math.Abs(Math.Sin(radians));
        float cosine = (float)Math.Abs(Math.Cos(radians));
        int originalWidth = bitmap.Width;
        int originalHeight = bitmap.Height;
        int rotatedWidth = (int)(cosine * originalWidth + sine * originalHeight);
        int rotatedHeight = (int)(cosine * originalHeight + sine * originalWidth);

        var rotatedBitmap = new SKBitmap(rotatedWidth, rotatedHeight);

        using (var surface = new SKCanvas(rotatedBitmap))
        {
            surface.Clear();
            surface.Translate(rotatedWidth / 2, rotatedHeight / 2);
            surface.RotateDegrees((float)angle);
            surface.Translate(-originalWidth / 2, -originalHeight / 2);
            surface.DrawBitmap(bitmap, new SKPoint());
        }
        return rotatedBitmap;
    }

    /// <summary>
    /// Given a Bitmap and a canvas surface, calculates the rectangle for it to be
    /// painted - at the right aspect ratio, and the right size, to fill the canvas
    /// as much as possible.
    /// </summary>
    /// <param name="bmp"></param>
    /// <param name="canvasSize"></param>
    /// <returns></returns>
    private static SKRect GetRenderRect(SKBitmap bmp, SKSize canvasSize)
    {
        float bmpAspectRatio = (float)bmp.Width / (float)bmp.Height;
        float renderHeight = canvasSize.Height;
        float renderWidth = renderHeight * bmpAspectRatio;
        float scaleFactor = 1.0f;

        if (renderHeight > canvasSize.Height)
            scaleFactor = canvasSize.Height / renderHeight;
        else if (renderWidth > canvasSize.Width)
            scaleFactor = canvasSize.Width / renderWidth;

        renderWidth *= scaleFactor;
        renderHeight *= scaleFactor;

        var origin = new SKPoint((canvasSize.Width - renderWidth) / 2.0f,
                                 (canvasSize.Height - renderHeight) / 2.0f );

        return new SKRect(origin.X, origin.Y, renderWidth + origin.X, renderHeight + origin.Y);
    }
}