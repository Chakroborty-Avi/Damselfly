@using Damselfly.Core.DbModels.Models.TransformationModels;

@inject HttpClient restClient
@inject ILogger<ImageCanvas> logger

@implements IDisposable

<div class="image-canvas">
    <SKGLView @ref="glViewRef" OnPaintSurface="OnPaintSurface" EnableRenderLoop="@isDragging" IgnorePixelScaling="false"
              class="@Class" @onmousedown="MouseDown" @onmouseup="MouseUp" @onmousemove="MouseMove" />
    <div class="tool-pallette">
        <MudSlider @bind-Value="lightenFactor" @bind-Value:after="Repaint" Style="width: 200px;" ValueLabel="true" />
        <MudIconButton Icon="@Icons.Material.Filled.Crop" Disabled="@(!CanCrop)" OnClick="DoCrop" />
        <MudIconButton Icon="@Icons.Material.Filled.RotateLeft" Disabled="@(!CanCrop)" OnClick="DoRotate" />
        <MudIconButton Icon="@Icons.Material.Filled.RotateRight" Disabled="@(!CanCrop)" OnClick="DoRotate" />
    </div>
</div>

@code {
    [Parameter]
    public Image Image { get; set; }

    [Parameter]
    public string Class { get; set; }

    private SKGLView glViewRef;
    private SKBitmap? sourceBitmap;
    private bool isHiRes = false;
    private int currentImageId = 0;
    private CancellationTokenSource loadCancellationSource = new();
    private string mouseStatus;
    private SKRect imageRect;
    private byte lightenFactor = 0;

    private SKPoint? dragStart;
    private SKPoint? dragEnd;
    private bool isDragging;
    private bool CanCrop => dragEnd.HasValue;

    private List<ITransform> transformations = new();

    private void Repaint()
    {
        if (glViewRef != null)
            glViewRef.Invalidate();
    }

    private void DoRotate()
    {

    }

    private void DoCrop()
    {
        if (dragStart.HasValue && dragEnd.HasValue)
        {
            var crop = new CropTransform
            {
                Left = (int)dragStart.Value.X,
                Top = (int)dragStart.Value.Y,
                Width = (int)(dragEnd.Value.X - dragStart.Value.X),
                Height = (int)(dragEnd.Value.Y - dragStart.Value.Y)
            };

            transformations.Add(crop);
            ClearDrag();
            Repaint();
        }
    }

    private float GetSurfaceDPI()
    {
        double dpi = 1;
        var obj = typeof(SKGLView).GetField("dpi", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

        if (obj != null)
            dpi = (double)obj.GetValue(glViewRef)!;

        return (float)dpi;
    }

    private SKPoint GetCoords(MouseEventArgs e)
    {
        var x = (float)e.OffsetX;
        var y = (float)e.OffsetY;
        return new SKPoint(x, y);
    }

    private void MouseMove(MouseEventArgs e)
    {
        if (isDragging)
        {
            dragEnd = GetCoords(e);
            Repaint();
        }
    }

    private void MouseDown(MouseEventArgs e)
    {
        dragStart = GetCoords(e);
        isDragging = true;
    }

    private void MouseUp(MouseEventArgs e)
    {
        if (dragStart.HasValue)
        {
            var mouseUp = GetCoords(e);

            if (dragStart == mouseUp)
                ClearDrag();
        }

        isDragging = false;
        Repaint();
    }

    private void ClearDrag()
    {
        dragStart = null;
        dragEnd = null;
    }

    private void SetBitmap(SKBitmap bitmap)
    {
        Dispose();
        sourceBitmap = bitmap;
        Repaint();
    }

    private async Task LoadImage(CancellationToken token)
    {
        var url = Image.ThumbUrl(ThumbSize.Medium);

        SKBitmap? bmp = null;
        try
        {
            using var imageStream = await restClient.GetStreamAsync(url, token);

            bmp = SKBitmap.Decode(imageStream);

            if (bmp != null && !token.IsCancellationRequested)
            {
                logger.LogInformation($"Loaded image {url} successfully");
                SetBitmap(bmp);
                isHiRes = false;
            }
            else
                logger.LogError($"Failed to decode {url} - bitmap was null");
        }
        catch (OperationCanceledException)
        {
            logger.LogWarning($"Cancelling low-res load as hi-res image is already loaded {url}");
        }
        catch (Exception ex)
        {
            logger.LogError($"Unable to load image {url}: {ex}");
        }
    }

    private async Task LoadHiResImage()
    {
        var url = Image.ThumbUrl(ThumbSize.ExtraLarge);

        SKBitmap? bmp = null;
        try
        {
            using var imageStream = await restClient.GetStreamAsync(url);

            bmp = SKBitmap.Decode(imageStream);

            if (bmp != null)
            {
                logger.LogInformation($"Loaded hi-res image {url} successfully");
                // Cancel the low-res load.
                loadCancellationSource.Cancel();
                SetBitmap(bmp);
                isHiRes = true;
            }
            else
                logger.LogError($"Failed to decode hi-res {url} - bitmap was null");
        }
        catch (Exception ex)
        {
            logger.LogError($"Unable to load hi-res image {url}: {ex}");
        }
    }

    protected override async Task OnParametersSetAsync()
    {

        if (Image != null)
        {
            if (Image.ImageId != currentImageId)
            {
                currentImageId = Image.ImageId;
                loadCancellationSource.TryReset();

                await LoadImage(loadCancellationSource.Token);
                await LoadHiResImage();
            }
        }
        else
        {
            currentImageId = 0;
            Dispose();
        }

        await base.OnParametersSetAsync();
    }

    public void Dispose()
    {
        if (sourceBitmap != null)
        {
            sourceBitmap.Dispose();
            sourceBitmap = null;
        }
    }

    private void OnPaintSurface(SKPaintGLSurfaceEventArgs e)
    {
        var dpi = GetSurfaceDPI();

        // the the canvas and properties
        var canvas = e.Surface.Canvas;

        // make sure the canvas is blank
        canvas.Clear(SKColors.Black);

        using var paint = new SKPaint
        {
            IsAntialias = true,
            StrokeWidth = 10f,
            StrokeCap = SKStrokeCap.Round,
            TextAlign = SKTextAlign.Center,
            TextSize = 24,
            Color = new SKColor(200, 200, 200),
        };

        var surfaceSize = e.BackendRenderTarget.Size;

        if (sourceBitmap != null)
        {
            var outputBmp = new SKBitmap((int)sourceBitmap.Width, (int)sourceBitmap.Height);
            // TODO This should be copy, not scale
            sourceBitmap.ScalePixels(outputBmp.PeekPixels(), SKFilterQuality.Medium);

            foreach (var transform in transformations)
            {
                if (transform is CropTransform)
                {
                    outputBmp = Crop(transform, outputBmp);
                }
            }

            var rect = GetRenderRect(outputBmp, surfaceSize);

            using var scaledImage = new SKBitmap((int)rect.Width, (int)rect.Height);
            sourceBitmap.ScalePixels(scaledImage.PeekPixels(), SKFilterQuality.Medium);

            using var filters = new SKPaint
            {
                ColorFilter = SKColorFilter.CreateLighting(SKColors.White, new SKColor(lightenFactor, lightenFactor, lightenFactor))
                // ColorFilter = SKColorFilter.CreateBlendMode(SKColors.Red, SKBlendMode.SrcIn)
                // ImageFilter = GetFilters()
            };

            canvas.DrawBitmap(outputBmp, rect, filters);

            if (dragStart.HasValue && dragEnd.HasValue)
            {
                using var rectPaint = new SKPaint
                {
                    Style = SKPaintStyle.Stroke,
                    StrokeCap = SKStrokeCap.Round,
                    StrokeWidth = 2f,
                    Color = SKColor.Parse("#ffffff"),
                    PathEffect = SKPathEffect.CreateDash(new[] { 5 * dpi, 2 * dpi }, 20)
                };

                canvas.DrawRect(dragStart.Value.X * dpi,
                                dragStart.Value.Y * dpi,
                                (dragEnd.Value.X - dragStart.Value.X) * dpi,
                                (dragEnd.Value.Y - dragStart.Value.Y) * dpi,
                                rectPaint);
            }

            canvas.DrawText($"{mouseStatus} - {Image.FileName}\n{surfaceSize}", surfaceSize.Width / 2, surfaceSize.Height - 10f, paint);
        }
    }

    public static SKBitmap Crop(ITransform transform, SKBitmap original)
    {
        CropTransform t = transform as CropTransform;

        if( t != null )
        {
            var bitmap = new SKBitmap(t.Width, t.Height);
            var cropRect = new SKRectI(t.Left, t.Top, t.Left + t.Width, t.Top + t.Height);
            original.ExtractSubset(bitmap, cropRect);
            return bitmap;
        }

        throw new ArgumentException("Transform was not crop");
    }

    // https://learn.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/blend-modes/separable
    // From https://learn.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/color-filters

    private SKColorFilter blackAndWhite =
SKColorFilter.CreateColorMatrix(new float[]
{
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0.21f, 0.72f, 0.07f, 0, 0,
                    0,     0,     0,     1, 0
                });
    private SKColorFilter muteColours =
            SKColorFilter.CreateColorMatrix(new float[]
            {
                    0.75f, 0.25f, 0.25f, 0, 0,
                    0.25f, 0.75f, 0.25f, 0, 0,
                    0.25f, 0.25f, 0.75f, 0, 0,
                    0, 0, 0, 1, 0
                            });
    private static void GetCrop()
    {
        //var bitmap = new SKBitmap(cropRect.Width, cropRect.Height);
        //original.ExtractSubset(bitmap, cropRect);
        //return bitmap;
    }

    /// <summary>
    /// Given a Bitmap and a canvas surface, calculates the rectangle for it to be
    /// painted - at the right aspect ratio, and the right size, to fill the canvas
    /// as much as possible.
    /// </summary>
    /// <param name="bmp"></param>
    /// <param name="canvasSize"></param>
    /// <returns></returns>
    private SKRect GetRenderRect(SKBitmap bmp, SKSize canvasSize)
    {
        float bmpAspectRatio = (float)bmp.Width / (float)bmp.Height;
        float renderHeight = canvasSize.Height;
        float renderWidth = renderHeight * bmpAspectRatio;
        float shrinkFactor = 1.0f;

        if (renderHeight > canvasSize.Height)
            shrinkFactor = canvasSize.Height / renderHeight;
        else if (renderWidth > canvasSize.Width)
            shrinkFactor = canvasSize.Width / renderWidth;

        renderWidth *= shrinkFactor;
        renderHeight *= shrinkFactor;

        float offsetX = (canvasSize.Width - renderWidth) / 2.0f;
        float offsetY = (canvasSize.Height - renderHeight) / 2.0f;

        imageRect = new SKRect(offsetX, offsetY, renderWidth + offsetX, renderHeight + offsetY);

        return imageRect;
    }
}